## Token

前后端分离的项目，已经跨站访问了，所以没有必要关心是否做CSRF验证

1. 配置settings 

    1.1 REST_FRAMEWORK
    - 默认配置是SessionAuthentication,BasicAuthentication
    - 查看源码可知Session只是从浏览器获取到user没有做具体逻辑
        - 浏览器中比较常见，浏览器会将Cookie和Session带给服务器
        - 前后端分离的项目中，主要是为了日后的扩展（移动端）推荐使用Token
    ```python
    REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
            'rest_framework.authentication.BasicAuthentication',
            'rest_framework.authentication.SessionAuthentication',
            'rest_framework.authentication.TokenAuthentication',
        )
    }
    ```

    1.2 
    ```python
    INSTALLED_APPS = [
        ...
        'rest_framework.authtoken',
    ]
    ```
    1.3 
    ```python
    python manage.py makemigration
    python manage.py migrate
    ```

2. 创建Token

    2.1 主路由配置

    ```python
    from rest_framework.authtoken import views
    urlpatterns += [
        url(r'^api-token-auth/', views.obtain\_auth\_token)
    ]
    ```

    2.2 使用Postman Post一个请求 http://127.0.0.1:8000/api-token-auth/
    ```python
    {
        "username":"rockyfire",
        "password":""
    }
    ```

    2.3 Postman Header中配置
    {"key":"Authorization","value":"Token 你的Token"}

3. Token 原理讲解

    [django从请求到返回都经历了什么](http://projectsedu.com/2016/10/17/django%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BF%94%E5%9B%9E%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/)

### ViewSets

场景：

有些数据是公开的，没有必要在settings配置全局

```python
REST_FRAMEWORK = {
'DEFAULT_AUTHENTICATION_CLASSES': (
        ...
        # 'rest_framework.authentication.TokenAuthentication'
    )
}
``` 

解决方案：

直接在View里面定义
```python
from rest_framework.authentication import TokenAuthentication

class CategoryViewSet(mixins.ListModelMixin, mixins.RetrieveModelMixin, viewsets.GenericViewSet):
    """
    List:
        商品分类列表数据详情
    """
    ...
    authentication_classes = (TokenAuthentication,)

```

## JSON Web Token

原理：

[前后端分离之JWT用户认证](https://www.jianshu.com/p/180a870a308a)

- Token设置验证过期
- 使用对称加密算法来加密用户ID形成Token

应用：

[REST framework JWT Auth](http://getblimp.github.io/django-rest-framework-jwt/)

### 自定义Auth

```python
AUTHENTICATION_BACKENDS=(
    'users.views.CustomBackend',
)
```


```python
from django.contrib.auth import get_user_model
from django.contrib.auth.backends import ModelBackend
from django.db.models import Q

User = get_user_model()


class CustomBackend(ModelBackend):
    """
        自定义用户验证 要重写authenticate
        可以使用手机号或用户名登录
    """

    try:
        # 用户名（手机号） 密码登录
        user = User.objects.get(Q(username=username) | Q(mobile=username))
        if user.check_password(password):
            return user

        # 手机号 验证码登录
        verify_records = VerifyCode.objects.filter(mobile=username).order_by('-add_time')
        if verify_records:
            # 最近的一次验证码
            last_recodes = verify_records[0]
            if last_recodes.code == password:
                return user

    except (AttributeError, UserProfile.DoesNotExist) as e:
        raise serializers.ValidationError("该用户名未注册")
    except Exception as e:
        return e
```

## 短信验证码登录

使用秒嘀发送短信验证码

添加验证码短信模板

配置管理>>验证码短信模板


```python
# !/usr/bin/env python3
# *coding:utf-8* 
__author__ = 'rockyfire'

import requests
import time
import hashlib
import json


class sendMessage(object):

    def __init__(self, accountsid, token):
        # 开发者主账号Token
        self.token = token
        # 开发者主账号ID
        self.accountSid = accountsid
        # 请求地址
        self.url = "https://api.miaodiyun.com/20150822/industrySMS/sendSMS"
        # 时间戳
        self.timestamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))

    def send_sms(self, code, mobile):
        params = {
            "accountSid": self.accountSid,
            # 短信模板ID
            "templateid": "146582552",
            # 短信变量
            "param": code,
            # 短信接收端手机号码
            "to": mobile,
            "timestamp": self.timestamp,
            # 签名
            "sig": hashlib.md5((self.accountSid + self.token + self.timestamp).encode('utf-8')).hexdigest(),
        }
        response = requests.post(self.url, data=params)
        re_dict = json.loads(response.text)
        # print(re_dict)
        return re_dict


if __name__ == "__main__":
    accountSid = ""
    token = ""
    timestamp = time.strftime('%Y%m%d%H%M%S', time.localtime(time.time()))
    sendMessage = sendMessage(accountSid, token)
    sendMessage.send_sms("2018", "")
```

如果是上线的项目要添加所在服务器地址

配置管理>>IP地址白名单

参考

[API开发者中心](http://www.miaodiyun.com/doc/https_sms.html)

### 集成到项目中

#### 创建Serializers 

```python
# !/usr/bin/env python3
# *coding:utf-8* 
__author__ = 'rockyfire'

import re
from datetime import datetime
from datetime import timedelta
from django.contrib.auth import get_user_model
from rest_framework import serializers
from mysite.settings import REGEX_MOBILE

from .models import VerifyCode

User = get_user_model()


class SmsSerializer(serializers.Serializer):

    mobile = serializers.CharField(max_length=11)

    def validated_mobile(self, mobile):
        """
        验证手机号码
        :return:
        """
        # 是否已注册

        if User.objects.filter(mobile=mobile).count():
            raise serializers.ValidationError("手机号已注册")

        # 手机号格式是否正确
        if not re.match(mobile, REGEX_MOBILE):
            raise serializers.ValidationError("手机格式不正确")

        # 验证码发送时间间隔
        one_mintes_ago = datetime.now() - timedelta(hours=0, minutes=1, seconds=0)

        # 当前时间大于一分钟之前的时间才可以再次发送请求
        if VerifyCode.objects.filter(add_time__gt=one_mintes_ago, mobile=mobile).count():
            raise serializers.ValidationError("距离上次发送不足一分钟，请稍后")

        return mobile
```

#### 编写View

```python
from rest_framework.mixins import CreateModelMixin
from rest_framework.viewsets import GenericViewSet
from rest_framework.response import Response
from rest_framework import status
from random import choice
from .serializers import SmsSerializer
from util.SendMSM import sendMessage
from .models import VerifyCode
from mysite.settings import REGEX_MOBILE, token, accountSid


class SmsCodeViewset(CreateModelMixin, GenericViewSet):
    """
        发送短信验证码
    """
    serializer_class = SmsSerializer

    def generate_code(self):
        """
        生成四位数字的验证码
        :return:
        """
        seeds = "123456789"
        random_str = []
        for i in range(4):
            random_str.append(choice(seeds))
        return "".join(random_str)

    def create(self, request, *args, **kwargs):
        """
        重写CreateModelMixin的crate
        :param request:
        :param args:
        :param kwargs:
        :return:
        """
        serializer = self.get_serializer(data=request.data)
        # raise_exception=True  错误就抛异常不会进入接下来的操作
        serializer.is_valid(raise_exception=True)

        # dict
        mobile = serializer.validated_data['mobile']
        code = self.generate_code()
        sendM = sendMessage(accountSid, token)
        sms_status = sendM.send_sms(code=code, mobile=mobile)

        if sms_status['respCode'] != "00000":
            return Response({
                "mobile": sms_status['respDesc']
            }, status=status.HTTP_400_BAD_REQUEST)
        else:
            code_record = VerifyCode(code=code, mobile=mobile)
            code_record.save()
            return Response({
                "mobile": mobile
            }, status=status.HTTP_201_CREATED)

```

#### 添加URL
```python
from rest_framework.routers import DefaultRouter

router = DefaultRouter()
router.register(r'code',SmsCodeViewset,base_name='smscode')
```

## 注册

编写UserRegSerializer
对前端传递过来的验证码进行判断

使用Filter而不使用Get是因为

- Get请求不到会抛出错误，Filter只是一个空数组
- Get有可能获取到两个数据报错，一样的验证码

```python
class UserRegSerializer(serializers.ModelSerializer):
    # 验证码是用户Model中没有的字段 
    # 使用方法和forms.CharField类似
    # 必填 最大长度 最小长度 只写 表单提示语 错误提示Error_messages
    # 允许空白 验证 唯一验证
    # 输入类型 
    code = serializers.CharField(required=True, max_length=4, min_length=4,
                                 write_only=True,
                                 help_text="验证码",
                                 label='验证码',
                                 error_messages = {
                                     "blank":"请输入验证码",
                                     "required":"请输入验证码",
                                     "max_length":"验证码格式错误",
                                     "min_length":"验证码格式错误",
                                 })

    username=serializers.CharField(required=True,allow_blank=False,
                                   label='用户名',
                                   validators=[UniqueValidator(queryset=User.objects.all(),message="该用户已经存在")])

    password=serializers.CharField(style={
        'input_type':'password'
    },label='密码',write_only=True,)

    # 设置密码
    # def create(self,validated_data):
    #     # 创建成功后可以取到User
    #     user=super(UserRegSerializer, self).create(validated_data=validated_data)
    #     # user继承AbstractUser，AbstractUser继承AbstractBaseUser 调用AbstractBaseUser的
    #     user.set_password(validated_data['password'])
    #     user.save()
    #     return user


    def validate_code(self, code):
        # try:
        #     verify_records=VerifyCode.objects.get(mobile=self.initial_data['username'],code=code)
        # except VerifyCode.DoesNotExist as e:
        #     pass
        # except VerifyCode.MultipleObjectsReturned as e:
        #     pass

        # initial_data[] 前端传递过来的值
        
        verify_records = VerifyCode.objects.filter(mobile=self.initial_data['username']).order_by('-add_time')
        if verify_records:
            # 最近的一次验证码
            last_recodes = verify_records[0]
            # 五分钟之前的时间
            five_mintes_ago = datetime.now() - timedelta(hours=0, minutes=5, seconds=0)
            # 保证在五分钟之内
            if five_mintes_ago > last_recodes.add_time:
                raise serializers.ValidationError('验证码过期')
            if last_recodes.code != code:
                raise serializers.ValidationError('验证码错误')

            # return code
        else:
            raise serializers.ValidationError('手机号未注册')

    # 全局的校验 重写Serializer的validate
    def validate(self, attrs):
        # 用户名字段赋值给手机字段
        attrs['mobile'] = attrs['username']
        # 删除验证码，Model没有验证码这个字段
        del attrs['code']
        # 返回
        return attrs

    class Meta:
        model = User
        fields = ('username', 'code', 'mobile', 'password')

```

```python
class UserViewset(CreateModelMixin, GenericViewSet):
    """

    """
    serializer_class = UserRegSerializer
    queryset = User.objects.all()

    # 注册后登录
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        # 保存后获取user
        user = self.perform_create(serializer)
        # 序列化的数据如{'username':,'moblie':} code和password没有是因为被设置为只写状态
        re_dict = serializer.data
        # obtain_jwt_token > ObtainJSONWebToken > JSONWebTokenSerializer > jwt_encode_handler(payload)>
        # payload = jwt_payload_handler(user) > jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER>
        ## 'JWT_PAYLOAD_HANDLER':'rest_framework_jwt.utils.jwt_payload_handler', 
        ## >jwt_payload_handler return payload

        payload = jwt_payload_handler(user)
        re_dict['token'] = jwt_encode_handler(payload)
        re_dict['name'] = user.name if user.name else user.username

        # get_success_headers是CreateModelMixin的方法，由源码可知 当返回的数据中有url时(data[api_settings.URL_FIELD_NAME]=data[url])
        # 重新定位到新地址。
        headers = self.get_success_headers(serializer.data)
        return Response(re_dict, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        return serializer.save()

```
### 密文保存

1. 重写ModelSerializer的create

```python
def create(self,validated_data):
    # 创建成功后可以取到User
    user=super(UserRegSerializer, self).create(validated_data=validated_data)
    # user继承AbstractUser，AbstractUser继承AbstractBaseUser 调用AbstractBaseUser的set_password
    user.set_password(validated_data['password'])
    user.save()
    return user
```

2. 使用信号量

signals.py
```python
# !/usr/bin/env python3
# *coding:utf-8* 
__author__ = 'rockyfire'

from django.conf import settings
from django.db.models.signals import post_save
from django.dispatch import receiver
from rest_framework.authtoken.models import Token

from django.contrib.auth import get_user_model
User = get_user_model()


@receiver(post_save, sender=User)
def create_auth_token(sender, instance=None, created=False, **kwargs):
    if created:
        instance.set_password(instance.password)
        instance.save()
```

在apps.py注册

```python
class UsersConfig(AppConfig):
    name = 'users'
    verbose_name='用户'


    def ready(self):
        import users.signals
```

### 退出登录

Json Web Token的Token数据是保存在客户端的。所以退出的时候只要清除Cookie即可
