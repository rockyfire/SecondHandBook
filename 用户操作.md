## 用户收藏

用户收藏的ViewSet

```python
class UserFavViewset(mixins.CreateModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet):
    queryset = UserFav.objects.all()
    serializer_class = UserFavSerializer
```

用户收藏的serializer

锁定当前用户（不能由用户选择其他用户进行收藏操作）。

```python
class UserFavSerializer(serializers.ModelSerializer):
    user = serializers.HiddenField(
        default=serializers.CurrentUserDefault()
    )

    class Meta:
        model = UserFav
        fields = ("user", "books", "id")
```

配置URL.py

```python
router.register(r'userfavs',UserFavViewset,base_name='userfavs')
```

更新：

获取当前用户的收藏列表：

让UserFavViewset继承mixins.ListModelMixin

校验相同收藏

- 在UserFav模型中设置unique_together
- 在UserFavSerializer中设置UniqueTogetherValidator

```python
class UserFav(models.Model):
    """
    用户收藏
    """
    ...
    class Meta:
        verbose_name = '用户收藏'
        verbose_name_plural = verbose_name
        unique_together = ("user", "books")
    ...
```
---
```python
class UserFavSerializer(serializers.ModelSerializer):
    ...
    class Meta:
        model = UserFav
        fields = ("user", "books", "id")
        # 校验相同收藏
        validators = [
            UniqueTogetherValidator(
                queryset=UserFav.objects.all(),
                fields=('user', 'books'),
                message="已经收藏",
            )
        ]
```

优化：

权限问题

IsAuthenticated 已经注册的用户（登录的情况下）
IsOwnerOrReadOnly 删除的时候验证权限(官方给的案例)
获取当前用户的收藏列表 重写get_queryset(self)


```python
# !/usr/bin/env python3
# *coding:utf-8* 
__author__ = 'rockyfire'

from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Object-level permission to only allow owners of an object to edit it.
    Assumes the model instance has an `owner` attribute.
    """

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request,
        # so we'll always allow GET, HEAD or OPTIONS requests.
        if request.method in permissions.SAFE_METHODS:
            return True

        # Instance must have an attribute named `owner`.
        return obj.user == request.user

class UserFavViewset(mixins.CreateModelMixin, mixins.ListModelMixin,mixins.DestroyModelMixin, viewsets.GenericViewSet):
    # queryset = UserFav.objects.all()
    serializer_class = UserFavSerializer
    permission_classes = (IsAuthenticated,IsOwnerOrReadOnly)
    authentication_classes = (JSONWebTokenAuthentication,SessionAuthentication)
    # 搜索的字段 该商品有没有被用户收藏 默认是查询UserFav——ID
    lookup_field =  "books_id"

    def get_queryset(self):
        return UserFav.objects.filter(user=self.request.user)


```

### 完善我的收藏

显示收藏商品的详情

```python
from books.serializers import BooksSerializer

class UserFavDetailSerializer(serializers.ModelSerializer):
    books = BooksSerializer()

    class Meta:
        model = UserFav
        fields = ("books", "id")
```

动态设置Serializer

```python
class UserFavViewset(mixins.CreateModelMixin, mixins.ListModelMixin, mixins.DestroyModelMixin, viewsets.GenericViewSet):
    """
    list:
        获取用户收藏列表
    retrieve：
        收藏商品详情
    create：
        收藏商品
    """
    # queryset = UserFav.objects.all()
    # serializer_class = UserFavSerializer
    permission_classes = (IsAuthenticated, IsOwnerOrReadOnly)
    authentication_classes = (JSONWebTokenAuthentication, SessionAuthentication)
    # 搜索的字段 该商品有没有被用户收藏
    lookup_field = "books_id"

    def get_queryset(self):
        return UserFav.objects.filter(user=self.request.user)

    # 重写get_serializer_class 而不是get_serializer
    def get_serializer_class(self):
        if self.action == "list":
            return UserFavDetailSerializer
        elif self.action == "create":
            return UserFavSerializer
        return UserFavSerializer
```

### Django Rest Framework API文档

配置Django Rest Framework的API文档路径

1. url(r'docs/',include\_docs\_urls(title='')),

- 根据在Router.register('')生成侧边栏文档
- F5刷新页面的时候，要重新验证Authentication
    - retrieve<-->read
    - help_text 可以加在Models Serializer Filter

## 获取用户信息

1. 重写RetrieveModelMixin.get_object(self):
    - 无论用户传递怎样的用户ID，后台只返回当前的用户

users/views.py

```python
    def get_object(self):
        return self.request.user
```

2. 重写APIView.get_permissions()获取权限

```python
    def get_permissions(self):
        """
        ViewSetMixin
        For example, to create a concrete view binding the 'GET' and 'POST' methods
        to the 'list' and 'create' actions...
        :return:
        """
        if self.action == "retrieve":
            return [permissions.IsAuthenticated()]
        elif self.action == "create":
            return []
        return []
```

3. 重写GenericAPIView.get\_serializer\_class() 

当首次创建的时候只有用户名（手机号），获取时是用户全部字段 动态调用Serializer

```python
    def get_serializer_class(self):
        if self.action == "retrieve":
            return UserDetailSerializer
        elif self.action == "create":
            return UserRegSerializer
        return UserDetailSerializer 
```

用户详细信息的序列化

```python
class UserDetailSerializer(serializers.ModelSerializer):
    """
    用户详情序列化类
    """

    class Meta:
        model = User
        fields = ('name', 'gender', 'birthday', 'email', 'mobile')

```

---

```python
class UserViewset(mixins.CreateModelMixin, mixins.UpdateModelMixin, mixins.RetrieveModelMixin, GenericViewSet):
    """
        用户
    """
    serializer_class = UserRegSerializer
    queryset = User.objects.all()
    authentication_classes = (authentication.SessionAuthentication, JSONWebTokenAuthentication)

    def get_serializer_class(self):
        if self.action == "retrieve":
            return UserDetailSerializer
        elif self.action == "create":
            return UserRegSerializer
        return UserDetailSerializer

    def get_permissions(self):
        """
        ViewSetMixin
        For example, to create a concrete view binding the 'GET' and 'POST' methods
        to the 'list' and 'create' actions...
        :return:
        """
        if self.action == "retrieve":
            return [permissions.IsAuthenticated()]
        elif self.action == "create":
            return []
        return []
    
    def get_object(self):
        return self.request.user
```

###  用户留言

跟用户收藏功能差不多

1. 序列化
2. ViewSet
3. URL


### 用户收货地址

跟用户收藏功能差不多

1. 序列化
2. ViewSet (viewsets.ModelViewSet(增删改查))
3. URL
