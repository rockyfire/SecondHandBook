
## 使用Rest Framework开发步骤:

##### 5-3,5-4

1. 在settings.py INSTALLED\_APPS配置'rest\_framework'
2. 序列化Books(继承serializers.Serializer)
3. 使用Restful Framework提供Response返回配置好的序列化Books
4. 修改urls.py引入BooksListViews.as_view()

在总路由配置docs Django Rest Framework生成自动文档
```
from rest_framework.documentation import include_docs_urls

urlpatterns = [
    ...
    url(r'docs/',include_docs_urls(title="电商")),
]
```

### Get

#### 序列化
serializers.py
```
from rest_framework import serializers

# class BooksSerializer(serializers.Serializer):
    # name = serializers.CharField(max_length=100, required=True)
    # click_num = serializers.IntegerField(default=0)
    # books_front_image = serializers.ImageField()

class BooksSerializer(ModelSerializer):  
    class Meta:
        model=Books
        fields=(
            'category','books_sn','name','click_num',
            'sold_num','fav_num','books_front_image','add_time',
        )
        # field="__all__"
```

#### 修改书籍View
views.py
```
from django.shortcuts import render
from .models import Books
from .serializers import BooksSerializer
from django.http import Http404
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

# Django restful framework
# Create your views here.
class BooksListView(APIView):
    """
        Books All List
    """
    def get(self,request,):
        books=Books.objects.all()[:10]
        # 多个对象，所以要配置many=True
        books_serializer=BooksSerializer(books,many=True)
        return Response(books_serializer.data)

```
访问http://localhost:8000/books/


Options(接口描述): 
- name View_name
- description:View_description
- renders:展示格式
- parses:可以解析的格式

优点：

- 使用serializers.ImageField()添加路径(Django Rest Framework会把settings.py中的MEDIA_URL+当前路径为图片路径)
- 使用**ModelSerializer**可以不用逐一添加字段(跟Modelform表单写法一致))
- Serializer可以嵌套(比如Books>>(Bookscategory))

```
class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model=BooksCategory
        fileds="__all__"

class BooksSerializer(serializers.ModelSerializer):
    category=CategorySerializer()
    class Meta:
        model=Books
        fields="__all__"
```

### Post

1. 在BookListView重写post(跟form表单写法一致)
1. 在BooksSerializer重写create 

#### 修改书籍View
views.py
```
class BooksListView(APIView):
    """
        Books All List
    """
    def post(self,request,format=None):
        serializer=BooksSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data,status=status.HTTP_201_CREATED)
        return Response(serializer.errors,status=status.HTTP_400_BAD_REQUEST)
```
#### 序列化
serializers.py
```
from rest_framework import serializers

class BooksSerializer(serializers.Serializer):
    # 验证前端传送过来的字段
    def create(self, validated_data):
        """
        Create and return a new Books instance,given the validated data
        :param validated_data:
        :return:
        """
        return Books.objects.create(**validated_data)
```

### GenericAPIView

views.py
```
# Django restful framework
# Create your views here.
# 查看源码可知ListModelMixin可以实现分页
class BooksListView(mixins.ListModelMixin,generics.GenericAPIView):
    """
        Books All List Mixins
    """
    queryset = Books.objects.all()[:10]
    serializer_class = BooksSerializer

    def get(self,request,*args,**kwargs):
        return self.list(request,*args,**kwargs)

# or
# ListAPIView继承了mixins.ListModelMixin,generics.GenericAPIView，同时定义get方法调用mixins.list()

class BooksListView(generics.ListAPIView):
    """
        Books All List Mixins
    """
    queryset = Books.objects.all()[:10]
    serializer_class = BooksSerializer
```

#### 分页显示

#####  1 配置settings 实现分页
mysites/settings.py
```
REST_FRAMEWORK={
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE':10,
}
```

##### 2继承PageNumberPagination

1. 继承PageNumberPagination
```
from rest_framework.pagination import PageNumberPagination

class LargeResultsSetPagination(PageNumberPagination):
    page_size = 10
    # 一页显示的个数
    page_size_query_param = 'page_size'
    # 自定义请求参数 默认是page=
    page_query_param = "p"
    max_page_size = 100
```
2. 覆盖pagination_class
```
class BooksListsView(generics.ListAPIView):
    """
        Books All List Mixins
    """
    queryset = Books.objects.all()
    serializer_class = BooksSerializer
    pagination_class = LargeResultsSetPagination
```

### ViewSets

views.py
```
from rest_framework import viewsets


class BooksListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet):
    """
        Books All List Mixins
    """
    queryset = Books.objects.all()[:10]
    serializer_class = BooksSerializer
```

#### 1 使用在urls.py配置的形式将Get请求绑定到list上

books/urls.py
```
from books.views import BooksListsView,BooksListViewSet

books_list=BooksListViewSet.as_view({
    # 绑定关系：将Get请求绑定到list上
    'get':'list',
    # 'post':'create'
})

urlpatterns = [
    ...
#   书籍列表页
    url(r'^$',books_list,name="books-list-set"),
]

```

#### 2 使用Routers取消绑定，简化配置 

在总路由配置 DefaultRouter
mysite/urls.py
```
from rest_framework.routers import DefaultRouter
from books.views import  BooksListViewSet

# 配置books的url
router=DefaultRouter()
router.register(r'books',BooksListViewSet)

urlpatterns = [
    url(r'^xadmin/', xadmin.site.urls),
    url(r'^media/(?P<path>.*)$',serve,{"document_root":MEDIA_ROOT}),
#   书籍列表页
#   url(r'books/',include("books.urls")),
    url(r'^',include(router.urls)),
    url(r'api-auth/',include('rest_framework.urls',namespace='rest_framework'))
]
```

## 搜索

#### 配置django-filters

settings.py
```
INSTALLED_APPS = [
    ...
    'django_filters',
]
```
#### 新建filters文件

filters.py
```
import django_filters
from .models import Books


class BooksFilter(django_filters.rest_framework.FilterSet):
    """
        书籍过滤类
    """
    price_min = django_filters.NumberFilter(name='price',lookup_expr='gte')
    price_max = django_filters.NumberFilter(name='price',lookup_expr='lte')

    class Meta:
        model = Books
        fields = ['price_min','price_max']

```

#### 修改书籍View

```python

class BooksListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet):
    """
        Books All List Mixins
    """
    queryset = Books.objects.all()
    serializer_class = BooksSerializer
    pagination_class = LargeResultsSetPagination
    
    filter_backends = (djnagofilters.DjangoFilterBackend,filters.SearchFilter)
    filter_class = BooksFilter
    search_fields = ('name',)
```

### 灵活配置

- '^' Starts-with search. 以上为开头
- '=' Exact matches.      精确过滤
- '@' Full-text search. (Currently only supported Django's MySQL backend.) 全文搜索
- '$' Regex search.       正则表达式搜索

## 排序

#### 更新书籍View

**filters.OrderingFilter**

```python
  class BooksListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet):
    """
        Books All List Mixins
    """
    ...
    filter_backends = (djnagofilters.DjangoFilterBackend,filters.SearchFilter,filters.OrderingFilter)
    filter_class = BooksFilter
    search_fields = ('$name',)
    ordering_fields = ('sold_num','add_time',)
```

>请求URL的路径如下:http://127.0.0.1:8000/books/?ordering=sold_num

## 书籍类别

#### 开发步骤
1. 编写书籍类别的序列化CategorySerializer 
2. 添加书籍类别View
3. router注册书籍类别View

```python

class CategorySerializer3(serializers.ModelSerializer):
    """
        书籍类别序列化 三级类目
    """

    class Meta:
        model = BooksCategory
        fields = "__all__"


class CategorySerializer2(serializers.ModelSerializer):
    """
        书籍类别序列化 二级类目 二级分类嵌套三级分类 many=True表示二级分类有多个（必须设置）
    """
    sub_cat = CategorySerializer3(many=True)

    class Meta:
        model = BooksCategory
        fields = "__all__"


class CategorySerializer(serializers.ModelSerializer):
    """
        书籍类别序列化 一级类目 一级分类嵌套二级分类 many=True表示二级分类有多个（必须设置）
    """
    sub_cat = CategorySerializer2(many=True)

    class Meta:
        model = BooksCategory
        fields = "__all__"

```
---
```python
class CategoryViewSet(mixins.ListModelMixin,viewsets.GenericViewSet):
    """
    List:
        书籍分类列表数据
    """
    # queryset = BooksCategory.objects.all()
    # 获取分类为一的数据 一级分类
    queryset = BooksCategory.objects.filter(category_type=1)

    serializer_class = CategorySerializer
    
```
---
```
router.register(r'bookscategory',CategoryViewSet)
```

#### 获取书籍分类详情

```
class CategoryViewSet(mixins.ListModelMixin,mixins.RetrieveModelMixin,viewsets.GenericViewSet):
    """
    List:
        书籍分类列表数据
    """
    queryset = BooksCategory.objects.all()
    serializer_class = CategorySerializer
    
```
优点：

本来要获取某个分类要传入分类的ID，比如url(r'^(?P<pk>[0-9]+)/$',...)现在只要继承mixins.RetrieveModelMixin,就可以实现。

#### Vue展示书籍分类数据

##### 跨域问题

访问的端口不一样
解决方法如下

- Vuejs的proxy.json
- Django-cors-headers

```
pip install django-cors-headers

INSTALLED_APPS = (
    ...
    'corsheaders',
)

MIDDLEWARE = [  # Or MIDDLEWARE_CLASSES on Django < 1.10
    ...
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    ...
]

CORS_ORIGIN_ALLOW_ALL = True
``` 

[django-cors-headers](https://github.com/ottoyiu/django-cors-headers)

#### 书籍

书籍的后台接口都已经实现，实现的一个功能就是
通过一级书籍类别查找到该一级书籍类别下的所有书籍

通过修改书籍的过滤类(BooksFilter)

```python
class BooksFilter(django_filters.rest_framework.FilterSet):
    """
        书籍过滤类
    """
    pricemin = django_filters.NumberFilter(name='shop_price', lookup_expr='gte')
    pricemax = django_filters.NumberFilter(name='shop_price', lookup_expr='lte')
    
    # 数据库中的分类序号
    top_category = django_filters.NumberFilter(method='top_category_filter')

    def top_category_filter(self, queryset, name, value):
        return queryset.filter(Q(category_id=value) | Q(category__parent_category_id=value) | Q(category__parent_category__parent_category_id=value))

    class Meta:
        model = Books
        fields = ['pricemin', 'pricemax']

```
### 书籍详情页

BooksListViewSet(mixins.ListModelMixin,viewsets.GenericViewSet)

*继承ListModelMixin，返回的是书籍列表，现在只需要配置RetrieveModelMixin，返回也有包含书籍详情*

序列化BooksImage这个外键
```python
class BooksImageSerializer(serializers.ModelSerializer):
    class Meta:
        model = BooksImage
        fields = ("image",)
```

BooksSerializer使用BooksImageSerializer

```python
class BooksSerializer(serializers.ModelSerializer):
    """
    书籍序列化
    """
    ...
    # images字段名是由BooksImage模型中外键维护名
    # class BooksImage(models.Model):
    #   books = models.ForeignKey(Books, verbose_name="书籍", related_name="images")
    #   ...
    images = BooksImageSerializer(many=True)
    ...
```

### 热卖书籍

添加过滤条件 is_hot

filters.py

```python
class BooksFilter(django_filters.rest_framework.FilterSet):
    """
        书籍过滤类
    """
    ...

    class Meta:
        model = Books
        fields = ['pricemin', 'pricemax','is_hot']
```

