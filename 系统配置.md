#### 修改Settings.py数据库驱动，SQLite3 >> MySQL

```
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': "mxshop",
        'USER': 'root',
        'PASSWORD': "123456",
        'HOST': "59.110.163.113",
        'OPTIONS': { 'init_command': 'SET storage_engine=INNODB;' }
    }
```

#### apps添加到环境变量中
```
AUTH_USER_MODEL = 'users.UserProfile'

import sys
sys.path.insert(0, BASE_DIR)
sys.path.insert(0, os.path.join(BASE_DIR, 'apps'))
sys.path.insert(0, os.path.join(BASE_DIR, 'extra_apps'))

sys.path -- 动态地改变Python搜索路径
sys.path.insert(0,…)这样新添加的目录会优先于其他目录被import检查
```

#### Model字段部分属性说明

- CharField 必须设置max_length
- help_text="" 可以在admin form里显示，不过即使不使用，也可以当做描述文档使用。
- **upload_to**该字段在数据库中只存储路径
- **choices**=<被选数据> 可以提供被选数据。如果一个字段设置了这个属性,在模版中如果我要显示这个字段，那么django模版系统就会将它默认解析为一个下来菜单，这样对于一个静态的下拉菜单式很方便的。

>related_name="" 外键关联，在多的一端维护
>models.ForeginKey("self",...)自我关联 比如一级类目下有多个二级类目，二级类目下有多个三级类目
>添加删除设置on_delete=models.CASCADE

##### class Meta： 
Django 模型类的Meta是一个内部类，它用于定义一些Django模型类的行为特性

verbose_name
给模型类起一个更可读的名字：

verbose_name_plural
这个选项是指定，模型的复数形式是什么。
如果不指定Django会自动在模型名称后加一个’s’

db_table
命名数据库表

```
# settings.py 里面设置MEDIA_ROOT and MEDIA_URL

MEDIA_ROOT = os.path.join(BASE_DIR, 'upload/')
MEDIA_URL = '/upload/' #这个是在浏览器上访问该上传文件的url的前缀

# models.py

class User(models.Model):
    avatar = ImageField(upload_to = 'avatar/')
    #实际的路径就是 MEDIA_ROOT/avatar/filename
    #所以可以用uoload_to来指定文件存放的前缀路径
```
---
```
# models.py

#让上传的文件路径动态地与user的名字有关
def upload_to(instance, fielname):
    return '/'.join([MEDIA_ROOT, instance.user_name, filename])

class User(models.Model):
    avatar = ImageField(upload_to = upload_to)
    user_name = CharField(max_length = 250)

```

参考

[Django之模型(model)中的choices字段的使用](http://quke.org/post/django-model-choices.html)

[django之对FileField字段的upload_to的设定](http://blog.csdn.net/alxandral_brother/article/details/53415551)

[Django 1.6 最佳实践: 如何正确使用 User Model](http://www.weiguda.com/blog/28/)

## 修改URL.py使用Xadmin

```
import xadmin

urlpatterns = [
    url(r'^xadmin/', xadmin.site.urls),
]
```

创建超级管理员
```
python manage.py createsuperuser 
```
修改xadmin的语言设置

settings.py
```
#设置时区
LANGUAGE_CODE = 'zh-hans'  #中文支持，django1.8以后支持；1.8以前是zh-cn
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True
USE_L10N = True
USE_TZ = False   #默认是Ture，时间是utc时间，由于我们要用本地时间，所用手动修改为false！！！！
```
## 导入数据


### 操作Model导入数据

- 修改数据(数据转化成Model进行保存)
- 独立使用Django的Model

```
import sys
import os

# 当前文件所在的绝对路径 .../mysite/db_tools
pwd = os.path.dirname(os.path.realpath(__file__))
# 返回上一层目录 .../mysite
sys.path.append(pwd+"../")
# 需要使用settings中的参数
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mysite.settings")

import django
django.setup()

ffrom books.models import Books, BooksImage
from data_tools.data.product_data import row_data
from django.contrib.auth import get_user_model

User = get_user_model()


for books_detail in row_data:
	books = Books()
	books.name = books_detail["name"]
	books.press = books_detail["press"]
	books.version = books_detail["version"]

	books.price = float(int(books_detail["price"].replace("￥", "").replace("元", "")))
	books.buyoutprice = float(int(books_detail["buyoutprice"].replace("￥", "").replace("元", "")))

	books.ship_free = books_detail['ship_free']
	books.desc = books_detail["desc"] if books_detail["desc"] is not None else ""
	books.photo = books_detail["photo"][0] if books_detail["photo"] else ""

	books.nums = int(books_detail['nums'])
	books.status = int(books_detail['status'])

	# category_name = books_detail["categorys"][-1]
	# category = BooksCategory.objects.filter(name=category_name)
	# if category:
	# 	books.category = category[0]
	user = User.objects.filter(username=books_detail['username'])
	if user:
		books.user = user[0]

	books.save()

	for books_image in books_detail["photo"]:
		books_image_instance = BooksImage()
		books_image_instance.image = books_image
		books_image_instance.books = books
		books_image_instance.save()
```

### 添加存放图片的路径 

settings.py

```
MEDIA_URL = '/media/' #这个是在浏览器上访问该上传文件的url的前缀
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
```

urls.py

```
from mysite.settings import MEDIA_ROOT
from django.views.static import serve

urlpatterns = [
    url(r'^media/(?P<path>.*)$',serve,{"document_root":MEDIA_ROOT})
]
```

### 前端ss

#### 前沿概念

- 前端工程化
    - webpack 
- 数据双向绑定
    - vue,vuex(组件间通信),vue-router,axios(ajax)
- 组件化开发
    - ES6 , babel(ES6-->ES5)

## Django-JSON

### 使用View返回Json数据

1. GoodsListView继承BaseView(from django.views.generic.base import View)
2. 重写Get请求(def get(self,request))
3. 获取数据(goods=Goods.objects.all()[:10])包装成字典(json\_dict={})放到列表里(json\_list=[])
4. Json序列化(json.dumps(json\_list)),定义返回内容格式content\_Type="application/json",返回HTTPResponse
5. 修改urls.py(url(r'^$',GoodsListView.as_view(),name="goods-list"))

#### 修改商品View

goods/view_base.py
```
# _*_ coding:utf-8 _*_
__author__ = 'rockyfire'

from django.views.generic.base import View
# from django.views.generic import ListView
from goods.models import Goods
from django.http import  HttpResponse
import json

class GoodsListView(View):
    # 重写get
    def get(self,request):
        """
        通过django的view实现商品列表页
        :return:
        """
        # json.lsit
        json_list=[]
        # 获取数据
        goods=Goods.objects.all()[:10]
        for good in goods:
            # json.dict
            json_dict={}
            json_dict['name']=good.name
            json_dict['category']=good.category.name
            json_dict['market_price']=good.market_price
            json_list.append(json_dict)
        # 返回HTTPResponse json序列化 定义返回内容格式content_type
        return HttpResponse(json.dumps(json_list),content_type="application/json")
```

####  配置商品的URL

goods/urls.py
```
from django.conf.urls import url,include
from goods.views_base import GoodsListView

urlpatterns = [
#   商品列表页
    url(r'^$',GoodsListView.as_view(),name="goods-list")
]
```

缺点:
- 没有实现序列化接口的类添加到Json里面会返回错误，比如datetime等
- 手动逐个添加json_dict

优化:

- 使用from django.core import serializers
- 使用django.forms.models import model\_to\_dict

```
取代手动添加的麻烦，但是没有序列化
from django.forms.models import model_to_dict
for good in goods:
    json_dict=model_to_dict(good)
    json_list.append(json_dict)
```

---

```
from django.http import  HttpResponse,JsonResponse
from django.core import serializers
json_data=serializers.serialize("json",goods)

#str 
# return HttpResponse(json_data,content_type="application/json")
# or

#dict 
json_data=json.loads(json_data)
return JsonResponse(json_data,safe=False)
```

>json.dumps : dict转成str
>json.loads ：str转成dict