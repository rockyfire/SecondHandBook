## 购物车


不使用ModelSerializer

灵活性不高，（添加购物车已有的书籍时报错，是因为书籍主键是由（Books和User共同决定的）重复添加会报错）

```python
class ShopCartDetailSerializer(serializers.ModelSerializer):
    books = BooksSerializer(many=False, )

    class Meta:
        model = ShoppingCart
        fields = "__all__"


class ShopCartSerializer(serializers.Serializer):
    user = serializers.HiddenField(
        default=serializers.CurrentUserDefault()
    )
    nums = serializers.IntegerField(
        required=True, label="数量", min_value=1,
        error_messages={
            "min_value": "商品数量必须大于1",
            "required": "必须填写数量"
        }
    )

    books = serializers.PrimaryKeyRelatedField(required=True, queryset=Books.objects.all())

    def create(self, validated_data):
        user = self.context['request'].user
        nums = validated_data['nums']
        books = validated_data['books']
        existed = ShoppingCart.objects.filter(user=user, books=books)

        if existed:
            existed = existed[0]
            existed.nums += nums
            existed.save()
        else:
            existed = ShoppingCart.objects.create(**validated_data)
        return existed

    def update(self, instance, validated_data):
        # 修改商品数量
        instance.nums = validated_data['nums']
        instance.save()
        return instance
```

ViewSet
URL

## 订单管理

为什么订单管理中的地址管理不使用外键：

如果（修改|删除）个人中心的地址，那么订单中的地址就会出错，所以不建议使用外键

订单不能允许修改，就没有必要使用viewsets.ModelViewSet


```python
class OrderSerializer(serializers.ModelSerializer):
    user = serializers.HiddenField(
        default=serializers.CurrentUserDefault()
    )

    pay_status = serializers.CharField(read_only=True)
    order_sn = serializers.CharField(read_only=True)
    trade_no = serializers.CharField(read_only=True)
    pay_time = serializers.CharField(read_only=True)

    add_time = serializers.HiddenField(
        default=timezone.now
    )

    def generate_order_sn(self):
        from random import Random
        import time
        random_ins = Random()
        order_sn = "{time_str}{userid}{restr}".format(
            time_str=time.strftime("%Y%m%d%H%M%S"),
            userid=self.context['request'].user.id,
            restr=random_ins.random(10, 99)
        )
        return order_sn

    def validate(self, attrs):
        attrs['order_sn'] = self.generate_order_sn()
        return attrs

    class Meta:
        model = OrderInfo
        fields = "__all__"
```

ViewSet 

获取购物车中的商品数据添加到订单中

```python
class OrderViewset(mixins.ListModelMixin, mixins.DestroyModelMixin,
                   mixins.CreateModelMixin, viewsets.GenericViewSet):
    """
    订单管理：
    """
    permission_classes = (IsAuthenticated, IsOwnerOrReadOnly)
    authentication_classes = (JSONWebTokenAuthentication, SessionAuthentication)

    serializer_class = OrderSerializer

    def get_queryset(self):
        return OrderInfo.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        order = serializer.save()
        # 返回购物车中的全部信息并将其添加到订单中
        shop_carts = ShoppingCart.objects.filter(user=self.request.user)
        for shop_cart in shop_carts:
            order_books = OrderBooks()
            order_books.order = order
            order_books.books = shop_cart.books
            order_books.books_num = shop_cart.nums
            order_books.save()

            # 清空购物车
            shop_cart.delete()
        return order
```

动态加载Serializer
```python
serializer.py

class OrderBooksSerialzier(serializers.ModelSerializer):
    # Model字段books
    books = BooksSerializer(many=False)

    class Meta:
        model = OrderBooks
        fields = "__all__"


# 个人中心使用
class OrderDetailSerializer(serializers.ModelSerializer):
    # 外键related_name
    books = OrderBooksSerialzier(many=True)

    class Meta:
        model = OrderInfo
        fields = "__all__"

viewset

# serializer_class = OrderSerializer

def get_serializer_class(self):
    if self.action == 'retrieve':
        return OrderDetailSerializer
    return OrderSerializer

```

### 远程调试代码

[远程调试代码](https://stackoverflow.com/questions/34359415/pycharm-ssh-interpter-no-such-file-or-directory)


## 支付管理

支付宝开发中心

[开发接入](https://open.alipay.com/developmentAccess/developmentAccess.htm)

[开发中心](https://docs.open.alipay.com/catalog)

选择 PKCS1(非Java适用) 密钥长度 2048
[生成RSA密钥](https://docs.open.alipay.com/291/105971/)

上传公钥给支付宝沙箱

[沙箱应用](https://openhome.alipay.com/platform/appDaily.htm)

并获取支付宝公钥

[签名](https://docs.open.alipay.com/291/106118)


```python
# -*- coding: utf-8 -*-

# pip install pycryptodome
__author__ = 'rockyfire'

from datetime import datetime
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA256
from base64 import b64encode, b64decode
from urllib.parse import quote_plus
from urllib.parse import urlparse, parse_qs
from urllib.request import urlopen
from base64 import decodebytes, encodebytes

import json


class AliPay(object):
    """
    支付宝支付接口
    """

    def __init__(self, appid, app_notify_url, app_private_key_path,
                 alipay_public_key_path, return_url, debug=False):
        self.appid = appid
        self.app_notify_url = app_notify_url
        self.app_private_key_path = app_private_key_path
        self.app_private_key = None
        self.return_url = return_url
        with open(self.app_private_key_path) as fp:
            self.app_private_key = RSA.importKey(fp.read())

        # 验证支付宝返回的消息
        self.alipay_public_key_path = alipay_public_key_path
        with open(self.alipay_public_key_path) as fp:
            self.alipay_public_key = RSA.import_key(fp.read())

        if debug is True:
            self.__gateway = "https://openapi.alipaydev.com/gateway.do"
        else:
            self.__gateway = "https://openapi.alipay.com/gateway.do"

    def direct_pay(self, subject, out_trade_no, total_amount, return_url=None, **kwargs):
        # 请求的相关参数
        biz_content = {
            "subject": subject,
            "out_trade_no": out_trade_no,
            "total_amount": total_amount,
            "product_code": "FAST_INSTANT_TRADE_PAY",
            # "qr_pay_mode":4
        }

        biz_content.update(kwargs)
        data = self.build_body("alipay.trade.page.pay", biz_content, self.return_url)
        return self.sign_data(data)

    # 公告请求参数在前 biz_content嵌套关系
    def build_body(self, method, biz_content, return_url=None):
        data = {
            "app_id": self.appid,
            "method": method,
            "charset": "utf-8",
            "sign_type": "RSA2",
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "version": "1.0",
            "biz_content": biz_content
        }

        if return_url is not None:
            data["notify_url"] = self.app_notify_url
            data["return_url"] = self.return_url

        return data

    def sign_data(self, data):
        data.pop("sign", None)
        # 排序后的字符串
        unsigned_items = self.ordered_data(data)
        # 使用&进行连接
        unsigned_string = "&".join("{0}={1}".format(k, v) for k, v in unsigned_items)
        # 签名
        sign = self.sign(unsigned_string.encode("utf-8"))
        # ordered_items = self.ordered_data(data)
        quoted_string = "&".join("{0}={1}".format(k, quote_plus(v)) for k, v in unsigned_items)

        # 获得最终的订单信息字符串
        signed_string = quoted_string + "&sign=" + quote_plus(sign)
        return signed_string

    def ordered_data(self, data):
        complex_keys = []
        for key, value in data.items():
            if isinstance(value, dict):
                complex_keys.append(key)

        # 将字典类型的数据dump出来
        for key in complex_keys:
            data[key] = json.dumps(data[key], separators=(',', ':'))

        return sorted([(k, v) for k, v in data.items()])

    def sign(self, unsigned_string):
        # 开始计算签名
        key = self.app_private_key
        signer = PKCS1_v1_5.new(key)
        signature = signer.sign(SHA256.new(unsigned_string))
        # base64 编码，转换为unicode表示并移除回车 byte - utf8字符串
        sign = encodebytes(signature).decode("utf8").replace("\n", "")
        return sign

    def _verify(self, raw_content, signature):
        # 开始计算签名
        key = self.alipay_public_key
        signer = PKCS1_v1_5.new(key)
        digest = SHA256.new()
        digest.update(raw_content.encode("utf8"))
        if signer.verify(digest, decodebytes(signature.encode("utf8"))):
            return True
        return False

    # 验证支付宝返回的结果是否合法
    def verify(self, data, signature):
        if "sign_type" in data:
            sign_type = data.pop("sign_type")
        # 排序后的字符串
        unsigned_items = self.ordered_data(data)
        message = "&".join(u"{}={}".format(k, v) for k, v in unsigned_items)
        return self._verify(message, signature)


if __name__ == "__main__":
    alipay = AliPay(
        appid="2016091300498040",
        # 异步接受支付宝返回的状态，进而修改该订单的状态
        app_notify_url="http://flycode.me/",
        app_private_key_path=u"private2048.txt",
        alipay_public_key_path="alipay_key_2048.txt",  # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥,
        debug=True,  # 默认False,
        # 支付成功后跳转到商户页面
        return_url="http://165.227.231.209:8087/"
    )

    # 支付宝返回数据验证
    return_url = 'http://165.227.231.209:8087/?total_amount=0.01&timestamp=2018-04-04+10%3A41%3A38&sign=cqc0wvkc%2BeoW276ECB2VuLUE9zNi3wQmVEtzGThCjXv7sHex866hskj9szHxmoegpXGARqlPM9EfM9kbloMFKPyaLY6RvcTZOpJvRNXkW3LVzg7c9z%2FinNKuSeF%2BzEdE04DEkjYp1WNX%2FGcQ7%2FMKooZnV%2F2VS6Y0Mwn%2FFELVocodpIbIE4z3rx0MSzw834AXm1zOT16md4Gh7pzVQCyfYaMcQ209oKqofGd%2FRsWBufN8Uxd0%2Bn4G15e2dRel0ArFPP3yE4azyhz7e9fzYGc2CHTFdpSrYSle3S0%2B2YGW2XESo1KU857fifpNQBWzQZ1jvaO2nHTKkVSVOCReveu3PA%3D%3D&trade_no=2018040421001004060200250636&sign_type=RSA2&auth_app_id=2016091300498040&charset=utf-8&seller_id=2088102175372352&method=alipay.trade.page.pay.return&app_id=2016091300498040&out_trade_no=201702021222&version=1.0'
    o = urlparse(return_url)
    query = parse_qs(o.query)
    processed_query = {}
    ali_sign = query.pop("sign")[0]
    for key, value in query.items():
        processed_query[key] = value[0]
    print(alipay.verify(processed_query, ali_sign))

    url = alipay.direct_pay(
        subject="测试订单",
        out_trade_no="201702021222",
        total_amount=0.01
    )
    # re_url = "https://openapi.alipaydev.com/gateway.do?{data}".format(data=url)
    # print(re_url)

```

## 支付宝的Return\_URL和Notify\_URL

Serializer
使用serializers.SerializerMethodField 修改订单的Serializer

OrderSerializer和OrderDetailSerializer

```python
alipay_url = serializers.SerializerMethodField(read_only=True)

def get_alipay_url(self, obj):
    alipay = AliPay(
        appid="2016091300498040",
        # 异步接受支付宝返回的状态，进而修改该订单的状态
        app_notify_url="http://165.227.231.209:8087/alipay/return/",
        app_private_key_path=private_key_path,
        alipay_public_key_path=ali_pub_key_path,  # 支付宝的公钥，验证支付宝回传消息使用.
        debug=True,  # 默认False,
        # 支付成功后跳转到商户页面
        return_url="http://165.227.231.209:8087/alipay/return/"
    )

    url = alipay.direct_pay(
        subject=obj.order_sn,
        out_trade_no=obj.order_sn,
        total_amount=obj.order_mount,
    )
    re_url = "https://openapi.alipaydev.com/gateway.do?{data}".format(data=url)

    return re_url
```

新建ViewSet

```python
class AlipayViewSet(APIView):
    def __init__(self):
        self.alipay = AliPay(
            appid="2016091300498040",
            # 异步接受支付宝返回的状态，进而修改该订单的状态
            app_notify_url="http://165.227.231.209:8087/alipay/return/",
            app_private_key_path=private_key_path,
            alipay_public_key_path=ali_pub_key_path,  # 支付宝的公钥，验证支付宝回传消息使用.
            debug=True,  # 默认False,
            # 支付成功后跳转到商户页面
            return_url="http://165.227.231.209:8087/alipay/return/"
        )

    def get(self, request):
        """
        return_url
        :param request:
        :return:
        """
        processed_dict = {}

        for key, value in request.GET.items():
            processed_dict[key] = value
        sign = processed_dict.pop('sign', None)

        verify_re = self.alipay.verify(processed_dict, sign)

        if verify_re is True:
            order_sn = processed_dict.get('out_trade_no', None)
            trade_no = processed_dict.get('trade_no', None)
            trade_status = processed_dict.get('trade_status', None)
            existed_orders = OrderInfo.objects.filter(order_sn=order_sn)
            for existed_order in existed_orders:
                existed_order.pay_status = trade_status
                existed_order.trade_no = trade_no
                existed_order.pay_time = datetime.now()
                existed_order.save()
            # 跳转回用户订单中心
            response = redirect('index')
            response.set_cookie('nexPath',"pay",max_age=2)
            return response
        else:
            response = redirect('index')
            return response

    def post(self, request):
        """
        notify_url
        :param request: 
        :return: 
        """
        processed_dict = {}

        for key, value in request.POST.items():
            processed_dict[key] = value
        sign = processed_dict.pop('sign', None)

        verify_re = self.alipay.verify(processed_dict, sign)

        if verify_re is True:
            order_sn = processed_dict.get('out_trade_no', None)
            trade_no = processed_dict.get('trade_no', None)
            trade_status = processed_dict.get('trade_status', None)
            existed_orders = OrderInfo.objects.filter(order_sn=order_sn)
            for existed_order in existed_orders:
                existed_order.pay_status = trade_status
                existed_order.trade_no = trade_no
                existed_order.pay_time = datetime.now()
                existed_order.save()
            return Response("success")
```


配置url

```python
from trade.views import AlipayViewSet
url(r'^alipay/return/', AlipayViewSet.as_view(), name='alipay'),
```

### Django 代理页面方式

构建 Vue 
```python
npm run build
```
将dist目录下文件分别导入Django Templates/Static

修改URL Settings配置

settings.py
```python
STATICFILES_DIRS=(
    os.path.join(BASE_DIR,"static"),
)

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        # 'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
---
urls.py
```python
from django.views.generic import TemplateView
url(r'^index',TemplateView.as_view(template_name="index.html"),name='index'),
```